/*
 * Copyright 2013 6WIND S.A.
 */

/*
 * Data entering from hooks in_* is passed asynchronously (duplicated) to hook
 * out. Packets can also be spontaneously generated by providing a template
 * with the setpacket command.
 *
 * Only a single packet can be buffered at once per hook, thus packets may be
 * lost if they are replaced before they are transmitted.
 *
 * Each hook may be configured to repeat packets at a given rate (bursts per
 * second) and burst size. A zero rate will send a single burst, a zero burst
 * size will disable traffic generation entirely.
 *
 * Configuring rate and burst size to generate 1 pps from all hooks at once.
 * This also sets the default for future hooks and setpacket command:
 *
 *  ngctl msg {node}: setrate 1
 *  ngctl msg {node}: setburst 1
 *
 * Setting per-hook rate to 42 bursts of 100 packets per second (4200 pps):
 *
 *  ngctl msg {node}: sethookrate '{ hook="foo" value=42 }'
 *  ngctl msg {node}: sethookburst '{ hook="foo" value=100 }'
 *
 * Configuring and enabling spontaneous generation of 64-bytes packets, four
 * of which are defined (first three bytes and the last one), the rest is
 * zero-filled:
 *
 *  ngctl msg {node}: setpacket '{ size=64 data=[ 0x2a 0x2b 0x2c 63=0x2d ] }'
 *
 * A string can also be specified. Note that the trailing NUL character must
 * be taken into account:
 *
 *  ngctl msg {node}: setpacket '{ size=4 data="foo" }'
 *
 * Disabling spontaneous packet generation:
 *
 *  ngctl msg {node}: setpacket '{ size=0 }'
 *
 * Limitations:
 *
 * The maximum packet size is defined by NG_GEN_MAX_PACKET_SIZE, currently
 * 65536 bytes.
 *
 * Due to the current implementation being based on callouts, the maximum
 * burst rate may be quite low depending on the architecture, about
 * 100 bursts/s (HZ value) without consuming 100% CPU, and about 50 Kbursts/s
 * (not accurately) otherwise.
 *
 * Burst size is artificially limited to NG_GEN_MAX_BURST_SIZE to prevent
 * CPU lockups.
 */

#include <netgraph/netgraph.h>
#include <netgraph/ng_parse.h>
#include <netgraph/ng_gen.h>
#ifdef __LinuxKernelVNB__
#include <linux/module.h>
#endif

struct ng_gen_hook_priv {
	struct ng_callout callout;
	struct vnb_timeval next_burst;
	uint32_t rate;
	uint32_t burst;
	uint32_t template_size;
	uint8_t template[NG_GEN_MAX_PACKET_SIZE];
};

struct ng_gen_priv {
	hook_p out;
	struct ng_gen_hook_priv sp;
};

typedef struct ng_gen_priv *priv_p;
typedef struct ng_gen_hook_priv *hpriv_p;

struct ng_gen_hook_uint32 {
	char hook[NG_HOOKSIZ];
	uint32_t value;
};

static const struct ng_parse_type ng_gen_hook_uint32_type = {
	.supertype = &ng_parse_struct_type,
	.info = &(const struct ng_parse_struct_field []){
		{
			.name = "hook",
			.type = &(const struct ng_parse_type){
				.supertype = &ng_parse_fixedstring_type,
				.info = &(const struct ng_parse_fixedstring_info){
					.bufSize = NG_HOOKSIZ,
				},
				.private = 0,
			},
			.alignment = 0,
		},
		{
			.name = "value",
			.type = &ng_parse_uint32_type,
		},
		{
			.name = NULL,
		},
	},
	.private = 0,
};

struct ng_gen_packet {
	uint32_t size;
	uint8_t data[];
};

static int
ng_gen_packet_type_getLength(const struct ng_parse_type *type,
			     const uint8_t *start, const uint8_t *buf)
{
	const struct ng_gen_packet *const p =
		(void *)(buf - offsetof(struct ng_gen_packet, data));

	(void)start;
	return p->size;
}

static const struct ng_parse_type ng_gen_packet_type = {
	.supertype = &ng_parse_struct_type,
	.info = &(const struct ng_parse_struct_field []){
		{
			.name = "size",
			.type = &ng_parse_uint32_type,
		},
		{
			.name = "data",
			.type = &(const struct ng_parse_type){
				.supertype = &ng_parse_bytearray_type,
				.info = &ng_gen_packet_type_getLength,
			},
			.alignment = 0,
		},
		{
			.name = NULL,
		},
	},
	.private = 0,
};

static const struct ng_cmdlist ng_gen_cmdlist[] = {
	{
		NGM_GEN_COOKIE,
		NGM_GEN_SET_RATE,
		"setrate",
		&ng_parse_uint32_type,
		NULL,
	},
	{
		NGM_GEN_COOKIE,
		NGM_GEN_GET_RATE,
		"getrate",
		NULL,
		&ng_parse_uint32_type,
	},
	{
		NGM_GEN_COOKIE,
		NGM_GEN_SET_BURST,
		"setburst",
		&ng_parse_uint32_type,
		NULL,
	},
	{
		NGM_GEN_COOKIE,
		NGM_GEN_GET_BURST,
		"getburst",
		NULL,
		&ng_parse_uint32_type,
	},
	{
		NGM_GEN_COOKIE,
		NGM_GEN_SET_HOOK_RATE,
		"sethookrate",
		&ng_gen_hook_uint32_type,
		NULL,
	},
	{
		NGM_GEN_COOKIE,
		NGM_GEN_GET_HOOK_RATE,
		"gethookrate",
		&ng_parse_string_type,
		&ng_gen_hook_uint32_type,
	},
	{
		NGM_GEN_COOKIE,
		NGM_GEN_SET_HOOK_BURST,
		"sethookburst",
		&ng_gen_hook_uint32_type,
		NULL,
	},
	{
		NGM_GEN_COOKIE,
		NGM_GEN_GET_HOOK_BURST,
		"gethookburst",
		&ng_parse_string_type,
		&ng_gen_hook_uint32_type,
	},
	{
		NGM_GEN_COOKIE,
		NGM_GEN_SET_PACKET,
		"setpacket",
		&ng_gen_packet_type,
		NULL,
	},
	{
		NGM_GEN_COOKIE,
		NGM_GEN_GET_PACKET,
		"getpacket",
		NULL,
		&ng_gen_packet_type,
	},
	{ 0, 0, NULL, NULL, NULL }
};

static void
ng_gen_traffic(void *v)
{
	node_p node;
	priv_p priv;
	hook_p hook = v;
	hpriv_p hpriv;
	hook_p out;
	uint32_t i;
	struct vnb_timeval now;
	struct vnb_timeval next_burst;
	unsigned long delay;

	/* hook may be NULL if priv->out was given but doesn't exist yet. */
	if ((hook == NULL) ||
	    ((node = hook->node) == NULL) ||
	    ((priv = node->private) == NULL))
		return;
	/* If there is no hook private data, use node's. */
	if ((hpriv = hook->private) == NULL)
		hpriv = &priv->sp;
	/* Check whether a burst must be generated now. */
	next_burst = hpriv->next_burst;
	microtime(&now);
	if ((now.tv_sec < next_burst.tv_sec) ||
	    ((now.tv_sec == next_burst.tv_sec) &&
	     (now.tv_usec < next_burst.tv_usec))) {
		/* Too early for the current burst. */
		delay = (((next_burst.tv_sec - now.tv_sec) * 1000000) +
			 ((next_burst.tv_usec - now.tv_usec) / 1000000));
		delay /= (hz * 1000000);
		/* If delay is zero but hz / rate isn't, change our mind. */
		if ((delay != 0) || ((hz / hpriv->rate) == 0))
			goto reschedule;
	}
	/* Set next burst occurence according to rate. */
	if ((i = hpriv->rate) != 0) {
		next_burst.tv_sec = (now.tv_sec + (1 / i));
		next_burst.tv_usec = (now.tv_usec + (1000000 / i));
		hpriv->next_burst = next_burst;
		/* Convert rate to delay before the next burst. */
		delay = (hz / i);
	}
	else
		delay = 0;
	/* If nothing can be sent, reschedule directly. */
	if ((out = priv->out) == NULL)
		goto reschedule;
	for (i = 0; (i < hpriv->burst); ++i) {
		struct mbuf *m;
		uint32_t size;
		int error;

		/* Abort if somehow the node became invalid during this. */
		if (node->flags & NG_INVALID)
			return;
		/*
		 * Generate a new packet from template and attempt to provide
		 * some protection against half updated packets by checking
		 * size before and after the copy.
		 */
		size = *(volatile uint32_t *)&hpriv->template_size;
		if ((size == 0) || (size > sizeof(hpriv->template)))
			continue;
		if ((m = m_alloc()) == NULL)
			continue;
		if ((m_copyfrombuf(m, 0, hpriv->template, size) != size) ||
		    (*(volatile uint32_t *)&hpriv->template_size != size))
			m_freem(m);
		else
			NG_SEND_DATA_ONLY(error, out, m);
		/* Don't care about errors. */
		(void)error;
	}
reschedule:
	/* Never if rate is zero. */
	if (hpriv->rate == 0)
		return;
	ng_callout_reset(&hpriv->callout, delay, ng_gen_traffic, hook);
}

static void
ng_gen_rehash(hook_p hook, hpriv_p hpriv)
{
	ng_callout_stop(&hpriv->callout);
	/*
	 * A zero burst size disables traffic generation. Otherwise, schedule
	 * the first burst as soon as possible.
	 */
	if (hpriv->burst == 0)
		return;
	/* Limit burst size. */
	if (hpriv->burst > NG_GEN_MAX_BURST_SIZE)
		hpriv->burst = NG_GEN_MAX_BURST_SIZE;
	microtime(&hpriv->next_burst);
	ng_callout_reset(&hpriv->callout, 0, ng_gen_traffic, hook);
}

static int
ng_gen_constructor(node_p *nodep, ng_ID_t id);

static int
ng_gen_rcvmsg(node_p node, struct ng_mesg *msg, const char *raddr,
	      struct ng_mesg **rptr, struct ng_mesg **nl_msg)
{
	struct ng_mesg *resp = NULL;
	int error = EINVAL;
	priv_p priv;
	size_t size;

	(void)nl_msg;
	if (msg->header.typecookie != NGM_GEN_COOKIE)
		goto end;
	if ((priv = NG_NODE_PRIVATE(node)) == NULL)
		goto end;
	size = msg->header.arglen;
	switch (msg->header.cmd) {
		hook_p hook;
		hpriv_p hpriv;
		struct ng_gen_hook_uint32 *hu;
		struct ng_gen_packet *pa;

	case NGM_GEN_SET_RATE:
		if (size != sizeof(priv->sp.rate))
			goto end;
		memcpy(&priv->sp.rate, msg->data, sizeof(priv->sp.rate));
		LIST_FOREACH(hook, &node->hooks, hooks) {
			hpriv_p hpriv = hook->private;

			if (hpriv == NULL)
				continue;
			hpriv->rate = priv->sp.rate;
			ng_gen_rehash(hook, hpriv);
		}
		ng_gen_rehash(priv->out, &priv->sp);
		break;
	case NGM_GEN_GET_RATE:
		NG_MKRESPONSE(resp, msg, sizeof(priv->sp.rate), M_NOWAIT);
		if (resp == NULL) {
			error = ENOMEM;
			goto end;
		}
		memcpy(resp->data, &priv->sp.rate, sizeof(priv->sp.rate));
		break;
	case NGM_GEN_SET_BURST:
		if (size != sizeof(priv->sp.burst))
			goto end;
		memcpy(&priv->sp.burst, msg->data, sizeof(priv->sp.burst));
		LIST_FOREACH(hook, &node->hooks, hooks) {
			hpriv_p hpriv = hook->private;

			if (hpriv == NULL)
				continue;
			hpriv->burst = priv->sp.burst;
			ng_gen_rehash(hook, hpriv);
		}
		ng_gen_rehash(priv->out, &priv->sp);
		break;
	case NGM_GEN_GET_BURST:
		NG_MKRESPONSE(resp, msg, sizeof(priv->sp.burst), M_NOWAIT);
		if (resp == NULL) {
			error = ENOMEM;
			goto end;
		}
		memcpy(resp->data, &priv->sp.burst, sizeof(priv->sp.burst));
		break;
	case NGM_GEN_SET_HOOK_RATE:
		if (size != sizeof(*hu))
			goto end;
		hu = (void *)msg->data;
		if (((hook = ng_findhook(node, hu->hook)) == NULL) ||
		    ((hpriv = hook->private) == NULL)) {
			error = ENOENT;
			goto end;
		}
		hpriv->rate = hu->value;
		ng_gen_rehash(hook, hpriv);
		break;
	case NGM_GEN_GET_HOOK_RATE:
		if ((size > NG_HOOKSIZ) || (size == 0))
			goto end;
		if (((hook = ng_findhook(node, msg->data)) == NULL) ||
		    ((hpriv = hook->private) == NULL)) {
			error = ENOENT;
			goto end;
		}
		NG_MKRESPONSE(resp, msg, sizeof(*hu), M_NOWAIT);
		if (resp == NULL) {
			error = ENOMEM;
			goto end;
		}
		hu = (void *)resp->data;
		strncpy(hu->hook, hook->name, sizeof(hu->hook));
		hu->value = hpriv->rate;
		break;
	case NGM_GEN_SET_HOOK_BURST:
		if (size != sizeof(*hu))
			goto end;
		hu = (void *)msg->data;
		if (((hook = ng_findhook(node, hu->hook)) == NULL) ||
		    ((hpriv = hook->private) == NULL)) {
			error = ENOENT;
			goto end;
		}
		hpriv->burst = hu->value;
		ng_gen_rehash(hook, hpriv);
		break;
	case NGM_GEN_GET_HOOK_BURST:
		if ((size > NG_HOOKSIZ) || (size == 0))
			goto end;
		if (((hook = ng_findhook(node, msg->data)) == NULL) ||
		    ((hpriv = hook->private) == NULL)) {
			error = ENOENT;
			goto end;
		}
		NG_MKRESPONSE(resp, msg, sizeof(*hu), M_NOWAIT);
		if (resp == NULL) {
			error = ENOMEM;
			goto end;
		}
		hu = (void *)resp->data;
		strncpy(hu->hook, hook->name, sizeof(hu->hook));
		hu->value = hpriv->burst;
		break;
	case NGM_GEN_SET_PACKET:
		if (size < sizeof(*pa))
			goto end;
		pa = (void *)msg->data;
		if (size < (sizeof(*pa) + pa->size))
			goto end;
		if (pa->size > sizeof(priv->sp.template)) {
			error = EMSGSIZE;
			goto end;
		}
		memcpy(priv->sp.template, pa->data, pa->size);
		priv->sp.template_size = pa->size;
		ng_gen_rehash(priv->out, &priv->sp);
		break;
	case NGM_GEN_GET_PACKET:
		NG_MKRESPONSE(resp, msg,
			      (sizeof(*pa) + priv->sp.template_size),
			      M_NOWAIT);
		if (resp == NULL) {
			error = ENOMEM;
			goto end;
		}
		pa = (void *)resp->data;
		pa->size = priv->sp.template_size;
		memcpy(pa->data, priv->sp.template, pa->size);
		break;
	default:
		goto end;
	}
	error = 0;
end:
	NG_RESPOND_MSG(error, node, raddr, resp, rptr);
	NG_FREE_MSG(msg);
	return error;
}

static int
ng_gen_shutdown(node_p node)
{
	hook_p hook;
	priv_p priv = node->private;

	node->flags |= NG_INVALID;
	ng_unname(node);
	ng_cutlinks(node);
	node->private = NULL;
	if (priv != NULL)
		ng_callout_stop_sync(&priv->sp.callout);
	LIST_FOREACH(hook, &node->hooks, hooks) {
		hpriv_p hpriv = hook->private;

		if (hpriv != NULL)
			ng_callout_stop_sync(&hpriv->callout);
	}
	NG_NODE_UNREF(node);
	return 0;
}

static int
ng_gen_newhook(node_p node, hook_p hook, const char *name)
{
	priv_p priv = node->private;
	hpriv_p hpriv;
	int error;

	if (priv == NULL)
		return EINVAL;
	if (!strcmp(name, NG_GEN_HOOK_OUT))
		goto hook_out;
	if ((!strncmp(name, NG_GEN_HOOK_IN, (sizeof(NG_GEN_HOOK_IN) - 1))) &&
	    (strlen(name) > (sizeof(NG_GEN_HOOK_IN) - 1)))
		goto hook_in;
	return EINVAL;
hook_out:
	if (priv->out != NULL)
		return EISCONN;
	priv->out = hook;
	ng_gen_rehash(priv->out, &priv->sp);
	return 0;
hook_in:
	if ((hpriv = ng_malloc(sizeof(*hpriv), (M_NOWAIT | M_ZERO))) == NULL)
		return ENOMEM;
	if ((error = ng_callout_init(&hpriv->callout)) != 0) {
		ng_free(hpriv);
		return error;
	}
	hpriv->rate = priv->sp.rate;
	hpriv->burst = priv->sp.burst;
	hpriv->template_size = 0;
	hook->private = hpriv;
	ng_gen_rehash(hook, hpriv);
	return 0;
}

static int
ng_gen_rcvdata(hook_p hook, struct mbuf *m, meta_p meta)
{
	node_p node;
	priv_p priv;
	hpriv_p hpriv;
	int error;
	uint32_t size;

	if (error = ENOTCONN,
	    ((node = hook->node) == NULL) ||
	    ((priv = node->private) == NULL))
		goto drop;
	if (hook == priv->out) {
		NG_SEND_DATA(error, hook, m, meta);
		return error;
	}
	if ((hpriv = hook->private) == NULL)
		goto drop;
	*(volatile uint32_t *)&hpriv->template_size = 0;
	size = m_copytobuf(hpriv->template, m, 0, sizeof(hpriv->template));
	NG_FREE_DATA(m, meta);
	hpriv->template_size = size;
	ng_gen_rehash(hook, hpriv);
	return error;
drop:
	NG_FREE_DATA(m, meta);
	return error;
}

static int
ng_gen_disconnect(hook_p hook)
{
	node_p node;
	priv_p priv;

	if (((node = hook->node) == NULL) ||
	    ((priv = node->private) == NULL))
		return 0;
	if (hook == priv->out)
		priv->out = NULL;
	else {
		hpriv_p hpriv = hook->private;

		hook->private = NULL;
		ng_callout_stop_sync(&hpriv->callout);
		ng_free(hpriv);
	}
	if (node->numhooks == 0)
		ng_rmnode(node);
	return 0;
}

static VNB_DEFINE_SHARED(struct ng_type, ng_gen_typestruct) = {
	.version = NG_VERSION,
	.name = NG_GEN_NODE_TYPE,
	.constructor = ng_gen_constructor,
	.rcvmsg = ng_gen_rcvmsg,
	.shutdown = ng_gen_shutdown,
	.newhook = ng_gen_newhook,
	.rcvdata = ng_gen_rcvdata,
	.disconnect = ng_gen_disconnect,
	.cmdlist = ng_gen_cmdlist,
};

static int
ng_gen_constructor(node_p *nodep, ng_ID_t id)
{
	struct ng_gen_priv *priv;
	int error = ng_make_node_common_and_priv
		(&ng_gen_typestruct, nodep, &priv, sizeof(*priv), id);

	if (error)
		return error;
	memset(priv, 0, sizeof(*priv));
	if ((error = ng_callout_init(&priv->sp.callout)) != 0) {
		ng_free(*nodep);
		*nodep = NULL;
		return error;
	}
	(*nodep)->private = priv;
	return 0;
}

NETGRAPH_INIT(gen, &ng_gen_typestruct);
NETGRAPH_EXIT(gen, &ng_gen_typestruct);

#ifdef __LinuxKernelVNB__

module_init(ng_gen_init);
module_exit(ng_gen_exit);

MODULE_AUTHOR("6WIND");
MODULE_DESCRIPTION("VNB gen node");
MODULE_LICENSE("6WIND");

#endif
